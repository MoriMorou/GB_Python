# =================================================
#  Ссылки/значения (подробнее об изменяемых типах)
# =================================================

n1 = 2
n2 = n1
n1 = 4
print("n1 = ", n1, "n2 = ", n2)

l1 = [1, 2, 3]
l2 = l1
l2.append(4)
print("l1 = ", l1, "l2 = ", l2)

# Переменная (в python) - это всего лишь указатель на объект в памяти.
# Если несколько переменных указывают на один и тот же ИЗМЕНЯЕМЫЙ объект,
# то, изменив объет по одной из ссылок, мы меняем его для всех остальных.

# Это особо важно понимать при передаче изменяемых объектов в функцию
# и при изменении объекта в цикле for in (который итерирует данный объект)


def modify(lst):
    # Лучше делать копию списка внутри функции
    # lst = lst[:]
    lst.append("new")
    return lst


my_list = [1, 2, 3]
mod_list = modify(my_list)

# Функция вернула измененный список
print('mod_list = ', mod_list)
# Но исходный список тоже изменился, подобное неявное поведение нежелательно для функций
print('my_list = ', my_list)

# Будьте аккуратны при работе с изменяемыми объектами, лучше работайте с их копиями
mod_list = modify(my_list)

my_list = [1, 2, 3]
# Теперь функция получит копию списка и не изменит исходный
mod_list = modify(my_list[:])
print('mod_list = ', mod_list)
print('my_list = ', my_list)

my_list = [1, -2, -4, 0, 5, -2]

# Удаляем все отрицательные элементы
for el in my_list:
    if el < 0:
        my_list.remove(el)

# Думаю, это не тот результат, которого вы ожидали
print("1)my_list after remove -->", my_list)

my_list = [1, -2, -4, 0, 5, -2]

# Итерируем по копии, а удаляем из оригинала
for el in my_list[:]:
    if el < 0:
        my_list.remove(el)

# А как хорошо
print("2)my_list after remove -->", my_list)

# Если нужно сделать полную копию, со всеми вложенными изменяемыми объектами, используем модуль copy
import copy

l = [[2, 3], [4, 6, [7, 8]]]
l_copy = copy.deepcopy(l)
l[0].append(10)

print('l_copy = ', l_copy)
